ls -l > out | ls -l > out2 // le premier file est rempli mais pas le deuxieme, sans les dep pas de pb
VOIR CE QUE RECOIT EXECVE

CD :

cd simple ne fait rien

cd // nous ememne dans '/' et pas dans '//'

cd /etc nous emene dans /private/etc alors que bash c'est dans /etc
PAS SUR QUE CE SOIT GRAVE

RETOUR D'ERREUR DE CD ET PWD A REVOIR, error code 1 il semblerait.

cd "garbage_name" 2>/dev/null, rien ne se passe mais pas de message d'erreur sur bash
nous si. Se renseigner sur cette ligne de commande.

ECHO

Pas un bug mais le truc du '-nnnnnnnnnnnnn -nnnnnnnnnnn'

echo sans arge = \n, a fix

faire l'echo $?

EXIT

checker le nombre d'arg, si + de 1 retour d'erreur CODE_ERREUR = 1
on exit mais mais exit s'ecrit dana la sortie standard

penser a passer l'arg d'exit au truc adapte pour que le code
d'erreur soit conserve

si arg non numerique transmis, exit se fait mais message d'erreur
"bash: exit: aaaaa: numeric argument required" avec CODE_ERREUR = 255

EXPORT 

semble avoir un pb avec les redir, genre export > out no fonctionar

quand export recoit un identifier invalide, type "$?", en gros une chaine de
caractere contenant certains char non alphabetique il semblerait, il retourne 
bash: export: `%': not a valid identifier CODE_ERREUR = 1

exception trouve : le #, l'_ l'* l'& le ;(l'esperluette normaleent ca marche pas mais vu 
que pour bash c'est un truc je sais pas trop quoi en faire) JE PENSE ON SEN FOUT

SEGFAULT dans :

#0 0x10260aa70 in ft_strlen_to_char (minishell:x86_64+0x100005a70)
    #1 0x10260b1e7 in _add_env (minishell:x86_64+0x1000061e7)
    #2 0x10260b3c4 in _export_env (minishell:x86_64+0x1000063c4)

apres cette commande "export =123";

il semble qu'exporter un truc du genre TEST+=100 -> TEST=100
comme si bash considerait que '+=' = '='

PIPE :

echo oui | echo non | echo something | grep oui 
CENSE NE RIEN AFFICHER, AFFICHE oui
echo oui | echo non | echo something | grep non
LUI N'AFFICHE RIEN, VISIBLEMENT GREP RECUP L'INFO DU PIPE 0
echo oui | echo non | echo something | grep something
CENSE AFFICHER SOMETHING, N'AFFICHE RIEN
cd .. | echo "something"
CENSE AFFICHER something AFFICHE ..

whoami | grep $USER > out SEGFAULT DANS :

#0 0x1094f7e1a in _set_dup_outfile (minishell:x86_64+0x100006e1a)
    #1 0x1094f8213 in _redir_last_cmd (minishell:x86_64+0x100007213)
    #2 0x1094f82ae in _set_pipes (minishell:x86_64+0x1000072ae)
    #3 0x1094f842e in _set_fd (minishell:x86_64+0x10000742e)
    #4 0x1094f7a71 in _ft_forks (minishell:x86_64+0x100006a71)
    #5 0x1094f7c31 in _ft_exe (minishell:x86_64+0x100006c31)

VISIBLEMENT PARCE QUE WHOMI EST UN FILE BINAIRE, GREP NE FONCTIONNE
QU'AVEC UNE VAR ENV LE RESTE DU TEMPS IL RENVOIE UNE ERREUR



REDIR 

ls > out 

RAJOUTE AU DEBUT DU DOC AU LIEU D'ECRASER

whereis ls | cat -e | cat -e > test 

SEGFAULT 

 #0 0x1094f7e1a in _set_dup_outfile (minishell:x86_64+0x100006e1a)
    #1 0x1094f8213 in _redir_last_cmd (minishell:x86_64+0x100007213)
    #2 0x1094f82ae in _set_pipes (minishell:x86_64+0x1000072ae)
    #3 0x1094f842e in _set_fd (minishell:x86_64+0x10000742e)
    #4 0x1094f7a71 in _ft_forks (minishell:x86_64+0x100006a71)
    #5 0x1094f7c31 in _ft_exe (minishell:x86_64+0x100006c31)

whereis grep > "FAUX NOM DE FICHIER"

ERREUR dup2 failed to run VERIFIER SI UN FICHIER EXISTE AVANT DE LE DUP

Unset :

ATTENTION TU CREE UNE ENV VAR OLDPWD A CHAQUE CHANGEMENT DE DOSSIER SANS LES EFFACER

Pareil que pour export, les charactere non Alpha autre que _ sont refuse
bash: unset: `2': not a valid identifier CODE ERREUR = 1

$USER$^USER$non.bomjour$USER$USER
cat <<ok1<<ok2<<ok3 > file1 > fil2 > file3 | echo bonjour -> ne print pas echo 

ECHO : 

n'imprime pas les '-' tout seul

EXIT : quand argument numerique, on exit ET on affiche le message d'erreur
+ CODE ERREUR A 255

RETOUR D'ERREUR :

CTRL + C sur une promt vide ou ou on a ecrit sans appuer sur Enter CODE_ERREUR = 1
Dans une commande style cat, CODE_ERREUR = 130

signaux : 

ctrl + / dans une commande bloquante : afficher quit 3 CODE_ERROR = 131

PARSING :

echo $? + $? colle le chiffre et le +